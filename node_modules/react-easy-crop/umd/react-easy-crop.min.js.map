{"version":3,"file":"react-easy-crop.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/helpers.ts","../../src/index.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = translateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = translateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n  return Math.min(maxPosition, Math.max(position, -maxPosition))\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition && rotation === 0 ? limitArea : noOp\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaSize.width) * 100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaSize.height) * 100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalWidth,\n      (croppedAreaPercentages.width * mediaSize.naturalWidth) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalHeight,\n      (croppedAreaPercentages.height * mediaSize.naturalHeight) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to iamge height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaSize.naturalWidth - sizePixels.width,\n        (croppedAreaPercentages.x * mediaSize.naturalWidth) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaSize.naturalHeight - sizePixels.height,\n        (croppedAreaPercentages.y * mediaSize.naturalHeight) / 100\n      )\n    ),\n  }\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): number {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  if (cropSize) {\n    const isHeightMaxSize = cropSize.height > cropSize.width\n    return isHeightMaxSize\n      ? cropSize.height / mediaZoom / croppedAreaPixels.height\n      : cropSize.width / mediaZoom / croppedAreaPixels.width\n  }\n\n  const aspect = croppedAreaPixels.width / croppedAreaPixels.height\n  const isHeightMaxSize = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n  return isHeightMaxSize\n    ? mediaSize.naturalHeight / croppedAreaPixels.height\n    : mediaSize.naturalWidth / croppedAreaPixels.width\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): { crop: Point; zoom: number } {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  const zoom = getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize)\n\n  const cropZoom = mediaZoom * zoom\n\n  const crop = {\n    x: ((mediaSize.naturalWidth - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaSize.naturalHeight - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\n/**\n *\n * Returns an x,y point once rotated around xMid,yMid\n */\nexport function rotateAroundMidPoint(\n  x: number,\n  y: number,\n  xMid: number,\n  yMid: number,\n  degrees: number\n): [number, number] {\n  const cos = Math.cos\n  const sin = Math.sin\n  const radian = (degrees * Math.PI) / 180 // Convert to radians\n  // Subtract midpoints, so that midpoint is translated to origin\n  // and add it in the end again\n  const xr = (x - xMid) * cos(radian) - (y - yMid) * sin(radian) + xMid\n  const yr = (x - xMid) * sin(radian) + (y - yMid) * cos(radian) + yMid\n\n  return [xr, yr]\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function translateSize(width: number, height: number, rotation: number): Size {\n  const centerX = width / 2\n  const centerY = height / 2\n\n  const outerBounds = [\n    rotateAroundMidPoint(0, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, height, centerX, centerY, rotation),\n    rotateAroundMidPoint(0, height, centerX, centerY, rotation),\n  ]\n\n  const minX = Math.min(...outerBounds.map(p => p[0]))\n  const maxX = Math.max(...outerBounds.map(p => p[0]))\n  const minY = Math.min(...outerBounds.map(p => p[1]))\n  const maxY = Math.max(...outerBounds.map(p => p[1]))\n\n  return { width: maxX - minX, height: maxY - minY }\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter(value => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport { Area, MediaSize, Point, Size } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  classNames,\n} from './helpers'\nimport cssStyles from './styles.css'\n\ntype Props = {\n  image?: string\n  video?: string\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  initialCroppedAreaPixels?: Area\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\nclass Cropper extends React.Component<Props, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: HTMLImageElement | null = null\n  videoRef: HTMLVideoElement | null = null\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = document.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      this.styleRef.innerHTML = cssStyles\n      document.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad()\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.remove()\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    document.removeEventListener('mousemove', this.onMouseMove)\n    document.removeEventListener('mouseup', this.onDragStopped)\n    document.removeEventListener('touchmove', this.onTouchMove)\n    document.removeEventListener('touchend', this.onDragStopped)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    this.computeSizes()\n    this.emitCropData()\n    this.setInitialCrop()\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = () => {\n    const { initialCroppedAreaPixels, cropSize } = this.props\n\n    if (!initialCroppedAreaPixels) {\n      return\n    }\n\n    const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n      initialCroppedAreaPixels,\n      this.mediaSize,\n      cropSize\n    )\n    this.props.onCropChange(crop)\n    this.props.onZoomChange && this.props.onZoomChange(zoom)\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef || this.videoRef\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n\n      this.mediaSize = {\n        width: mediaRef.offsetWidth,\n        height: mediaRef.offsetHeight,\n        naturalWidth: this.imageRef?.naturalWidth || this.videoRef?.videoWidth || 0,\n        naturalHeight: this.imageRef?.naturalHeight || this.videoRef?.videoHeight || 0,\n      }\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            mediaRef.offsetWidth,\n            mediaRef.offsetHeight,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n      this.setState({ cropSize }, this.recomputeCropPosition)\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    document.addEventListener('mousemove', this.onMouseMove)\n    document.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    document.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', this.onDragStopped)\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) window.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = window.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = window.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center)\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.props.zoom - (e.deltaY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point)\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = window.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const zoomPoint = this.getPointOnContainer(point)\n    const zoomTarget = this.getPointOnMedia(zoomPoint)\n    const newZoom = Math.min(this.props.maxZoom, Math.max(zoom, this.props.minZoom))\n    const requestedPosition = {\n      x: zoomTarget.x * newZoom - zoomPoint.x,\n      y: zoomTarget.y * newZoom - zoomPoint.y,\n    }\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          requestedPosition,\n          this.mediaSize,\n          this.state.cropSize,\n          newZoom,\n          this.props.rotation\n        )\n      : requestedPosition\n\n    this.props.onCropChange(newPosition)\n    this.props.onZoomChange(newZoom)\n  }\n\n  emitCropData = () => {\n    if (!this.state.cropSize) return\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    const { croppedAreaPercentages, croppedAreaPixels } = computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n    this.props.onCropComplete &&\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={el => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames('reactEasyCrop_Image', mediaClassName)}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={(el: HTMLImageElement) => (this.imageRef = el)}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames('reactEasyCrop_Video', mediaClassName)}\n              {...mediaProps}\n              src={video}\n              ref={(el: HTMLVideoElement) => (this.videoRef = el)}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            />\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","restrictPosition","position","mediaSize","cropSize","zoom","rotation","_a","width","height","x","restrictPositionCoord","y","maxPosition","Math","min","max","getDistanceBetweenPoints","pointA","pointB","sqrt","pow","getRotationBetweenPoints","atan2","PI","limitArea","value","noOp","_max","getCenter","a","rotateAroundMidPoint","xMid","yMid","degrees","cos","sin","radian","translateSize","centerX","centerY","outerBounds","minX","map","maxX","minY","classNames","_i","args","filter","join","trim","_this","naturalWidth","naturalHeight","hasWheelJustStarted","e","preventDefault","document","removeEventListener","onMouseMove","onDragStopped","onTouchMove","containerRef","onWheel","wheelTimer","clearTimeout","computeSizes","emitCropData","setInitialCrop","props","onMediaLoaded","initialCroppedAreaPixels","_b","croppedAreaPixels","mediaZoom","aspect","getZoomFromCroppedAreaPixels","cropZoom","crop","onCropChange","onZoomChange","mediaRef","imageRef","videoRef","containerRect","getBoundingClientRect","offsetWidth","offsetHeight","videoWidth","videoHeight","mediaWidth","mediaHeight","containerWidth","containerHeight","fittingWidth","fittingHeight","getCropSize","setState","recomputeCropPosition","addEventListener","onDragStart","Cropper","getMousePoint","onDrag","passive","touches","onPinchStart","getTouchPoint","onPinchMove","dragStartPosition","dragStartCrop","onInteractionStart","rafDragTimeout","window","cancelAnimationFrame","requestAnimationFrame","state","undefined","offsetX","offsetY","requestedPosition","newPosition","cleanEvents","onInteractionEnd","point","newZoom","deltaY","zoomSpeed","setNewZoom","setTimeout","Error","left","top","zoomPoint","getPointOnContainer","zoomTarget","getPointOnMedia","maxZoom","minZoom","limitAreaFn","croppedAreaPercentages","widthInPixels","round","heightInPixels","sizePixels","onCropComplete","__","constructor","create","__extends","zoomWithScroll","preventZoomSafari","disableAutomaticStylesInjection","styleRef","createElement","setAttribute","innerHTML","head","appendChild","complete","onMediaLoad","remove","clearScrollEvent","prevProps","lastPinchDistance","lastPinchRotation","center","rafPinchTimeout","distance","newRotation","onRotationChange","image","video","mediaProps","transform","cropShape","showGrid","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","React","onMouseDown","onTouchStart","ref","el","style","className","alt","src","onLoad","autoPlay","loop","muted","onLoadedMetadata","controls","classes","Number","clientX","clientY","touch","Component"],"mappings":"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"}